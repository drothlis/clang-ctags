#!/usr/bin/env python

import os.path
import StringIO
import sys
import traceback

import clang.cindex
from clang.cindex import CompilationDatabase, CursorKind, Diagnostic


def main(argv):
    global args
    args = parse_args(argv)

    formatter = Etags() if args.etags else Ctags()

    if args.compile_commands:
        db = CompilationDatabase.fromDirectory(
            args.compile_commands if os.path.isdir(args.compile_commands)
            else os.path.dirname(args.compile_commands))
        source_files = [os.path.realpath(x) for x in args.source_files]
        for f in source_files:
            debug("Processing " + f)
            for c in db.getCompileCommands(f) or []:
                debug("* Found compile command: " + " ".join(list(c.arguments)))
                with cwd(c.directory):
                    debug("  run from directory: " + os.getcwd())
                    do_tags(list(c.arguments)[1:], formatter, source_files)
    else:
        do_tags(args.compiler_command_line, formatter)

    if args.output == "-":
        out = sys.stdout
    else:
        out = open(args.output, ("a" if args.append else "w") + "b")
    out.write(formatter.getvalue())


def do_tags(compiler_command_line, formatter, source_files=[]):
    index = clang.cindex.Index.create()
    try:
        tu = index.parse(None, compiler_command_line)  # a Translation Unit
    except Exception as e:
        debug(traceback.format_exc())
        error("Clang failed to parse '%s'" % " ".join(compiler_command_line))

    errors = [d for d in tu.diagnostics
              if d.severity in (Diagnostic.Error, Diagnostic.Fatal)]
    if len(errors) > 0:
        debug("\n".join([d.spelling for d in errors]))
        error("File '%s' failed clang's parsing and type-checking" %
              tu.spelling)

    if not source_files:
        source_files = [os.path.realpath(tu.spelling)]

    for c in tu.cursor.get_children():
        do_cursor(c, formatter, source_files)


def do_cursor(cursor, formatter, source_files):
    if (not cursor.location.file or
            os.path.realpath(cursor.location.file.name) not in source_files):
        return

    if is_definition(cursor):
        parents = semantic_parents(cursor)
        formatter.tag(cursor, "::" + "::".join(parents + [cursor.displayname]))
        for i in range(len(parents) + 1):
            formatter.tag(cursor, "::".join(parents[i:] + [cursor.displayname]))

    if should_tag_children(cursor):
        for c in cursor.get_children():
            do_cursor(c, formatter, source_files)


def is_definition(cursor):
    return cursor.is_definition() and not cursor.kind in [
        CursorKind.CXX_ACCESS_SPEC_DECL,
        CursorKind.TEMPLATE_TYPE_PARAMETER,
        CursorKind.UNEXPOSED_DECL,
        ]


def semantic_parents(cursor):
    import collections

    p = collections.deque()
    c = cursor.semantic_parent
    while c and is_named_scope(c):
        p.appendleft(c.displayname)
        c = c.semantic_parent
    return list(p)


def should_tag_children(cursor):
    return is_named_scope(cursor) or cursor.kind in [
        # 'extern "C" { ... }' should be LINKAGE_SPEC but is UNEXPOSED_DECL
        CursorKind.UNEXPOSED_DECL,
        ]


def is_named_scope(cursor):
    return cursor.kind in [
        CursorKind.NAMESPACE,
        CursorKind.STRUCT_DECL,
        CursorKind.UNION_DECL,
        CursorKind.ENUM_DECL,
        CursorKind.CLASS_DECL,
        CursorKind.CLASS_TEMPLATE,
        CursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION,
        ]


class Etags:
    """Write tags in the format understood by Emacs.

    See http://bzr.savannah.gnu.org/lh/emacs/trunk/annotate/head:/etc/ETAGS.EBNF
    """

    def __init__(self):
        self.tags = {}  # {file: [(line, tag, linenumber, bytenumber), ...]}
        self.current_file_name = None
        self.current_file_lines = None

    def tag(self, cursor, tagname):
        """The complete tags file entry for symbol 'tag'."""
        if self.current_file_name != os.path.realpath(cursor.location.file.name):
            self.current_file_name = os.path.realpath(cursor.location.file.name)
            with open(self.current_file_name) as f:
                self.current_file_lines = f.readlines()

        if self.current_file_name not in self.tags:
            self.tags[self.current_file_name] = []

        self.tags[self.current_file_name].append((
            self.current_file_lines[cursor.location.line - 1].rstrip(),
            tagname,
            cursor.location.line,
            cursor.location.offset))

    def getvalue(self):
        out = StringIO.StringIO()
        for f in self.tags:
            out.write("\x0c\x0a" + f + ",\x0a")
            for t in self.tags[f]:
                out.write("%s\x7f%s\x01%d,%d\x0a" % t)
        return out.getvalue()


class Ctags:
    """Write tags in the format understood by Vi.

    Not yet implemented. The man page for Exuberant Ctags
    (http://ctags.sourceforge.net) documents the tags file format.
    """

    def  __init__(self):
        error("Ctags (vi) format not implemented. "
              "Use '-e' for etags (Emacs) format.")


class cwd:
    """Run a block of code from a specified working directory"""
    def __init__(self, dir):
        self.dir = dir

    def __enter__(self):
        self.old_dir = os.getcwd()
        os.chdir(self.dir)

    def __exit__(self, exc_type, exc_value, traceback):
        os.chdir(self.old_dir)


def parse_args(argv):
    import argparse
    import re

    parser = argparse.ArgumentParser(
        description="Generate tag file for C++ source code.",
        usage="\nclang-ctags [options] -- <compiler command line>"
              "\nclang-ctags [options] --compile-commands=<compile_commands.json>"
              " <source-file> ...")
    parser.add_argument("-e", action="store_true",
                        help='output tags in Emacs format (default: vi format)'
                             ' (implied if the program name contains "etags")')
    parser.add_argument("-a", "--append", action="store_true",
                        help="append tag entries to existing tag file")
    parser.add_argument("-f", "-o", "--output", metavar="FILE",
                        help='write the tags to %(metavar)s;'
                             ' "-" writes tags to stdout'
                             ' (default: "tags", or "TAGS" when -e supplied)')
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="enable debugging output")
    parser.add_argument("--version", action="version",
                        version="clang-ctags 1.0rc")
    parser.add_argument("--compile-commands", metavar="COMPILE_COMMANDS.JSON",
        help="database of compilation command lines for each source file")
    parser.add_argument("args", nargs="+", help=argparse.SUPPRESS)

    a = parser.parse_args(argv[1:])
    a.etags = bool(a.e or re.search("etags", argv[0]))
    if not a.output:
        a.output = "TAGS" if a.etags else "tags"
    if a.compile_commands:
        a.source_files = a.args
    else:
        a.compiler_command_line = a.args
    return a


def debug(s):
    if args.verbose:
        sys.stderr.write(s + "\n")


def error(s):
    sys.stderr.write("%s: Error: %s\n" % (os.path.basename(sys.argv[0]), s))
    sys.exit(1)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
